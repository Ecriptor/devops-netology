# Ответы на вопросы

## Задача 1

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её нужно прервать.<br>
Вы как инженер поддержки решили произвести данную операцию:<br>
напишите список операций, которые вы будете производить для остановки запроса пользователя
```
# посмотреть список выполнящихся оппераций в данный момент
db.currentOp()
№завершить зависшую операцию
db.killOp(<opId>)
```
предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB
```
#можно ограничить максимальное время на выполнение задачи, например 3-мя минутами
db.collection.find().maxTimeMS(180000)
```

## Задача 2
Перед выполнением задания познакомьтесь с документацией по Redis latency troobleshooting.<br>
Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и увеличивается пропорционально количеству реплик сервиса.<br>
При масштабировании сервиса до N реплик вы увидели, что:
* сначала рост отношения записанных значений к истекшим
* Redis блокирует операции записи
Как вы думаете, в чем может быть проблема?
```
Пямять забилась истекшими ключами, которые еще не удалились. Redis заблокировался, чтобы вывести из БД удаленные ключи и снизить их количество менее чем 25%.
```

## Задача 3
Перед выполнением задания познакомьтесь с документацией по Common Mysql errors.<br>
Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы, пользователи начали жаловаться на ошибки вида:<br>
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '<br>
Как вы думаете, почему это начало происходить и как локализовать проблему?<br>
Какие пути решения данной проблемы вы можете предложить?
```
Из-за большого размера таблицы время выборки данных превышает значение net_read_timeout (по умолчанию 30 секунд).
Сервер явно не справляется с большим количеством запросов и дропает соединения.
Можно увеличить net_read_timeout и включить slow_log.
```
## Задача 4
Перед выполнением задания ознакомтесь со статьей Common PostgreSQL errors из блога Percona.<br>
Вы решили перевезти гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с большим объемом данных лучше, чем MySQL.<br>
После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:<br>
postmaster invoked oom-killer<br>
Как вы думаете, что происходит?<br>
Как бы вы решили данную проблему?
```
Закончилась память на сервере т.к. запустился ОмНомНом-killer. Если позволяют финансы - добавить оперативки.
Но лучше потюнить конфиг postgresql, а именно:
work_mem
shared_buffers
effective_cache_size
maintenance_work_mem
```
